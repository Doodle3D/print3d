#include <errno.h>
#include <strings.h> /* for error generated by Eclipse on FD_ZERO()? */
#include <unistd.h>
#include <sys/select.h>
#include <sys/socket.h>
#include "Server.h"

using std::string;

const bool Server::FORK_BY_DEFAULT = true;
const int Server::SOCKET_MAX_BACKLOG = 5; //private

Server::Server(const string& serialPortPath, const string& socketPath)
: serialPortName_(serialPortPath), socketPath_(socketPath),
  log_(Logger::getInstance()), socketFd_(-1)
{ /* empty */ }

Server::~Server() {
	closeSocket();
	serial_.close();
}

//returns -1 on error, >0 after fork or 0 after successful (not-fork) exit
int Server::start(bool fork) {
	if (!openSocket()) return false;

	if (fork) {
		//fork as late as possible (before any possibly lengthy operations like serial port things)
		int rv = forkProcess();
		if (rv < 0) {
			closeSocket();
		}

		if (rv != 0) return rv; //return rv unless we are a successfuly spawned child process
	}

	//HIER *** foutafhandeling niet vergeten
	openPort();
	//set (detected?) speed

	fd_set masterFds;
	fd_set readFds;
	FD_ZERO(&masterFds);
	FD_SET(socketFd_, &masterFds);

	while (true) {
		//TODO: add timeout (or something more complex to accomodate periodic temperature readings etc)

		readFds = masterFds;
		if (log_.checkError(
				select(FD_SETSIZE, &readFds, NULL, NULL, NULL),
				"error in select()")) {
			//TODO: handle error (close down server <- needs function... and return with proper error value)
		}

		if (FD_ISSET(socketFd_, &readFds)) {
			socklen_t len = sizeof(struct sockaddr_un);
			struct sockaddr_un remote;
			int connFd = accept(socketFd_, (struct sockaddr*)&remote, &len);

			FD_SET(connFd, &masterFds);
			//TODO: store connFd and add to readFds
		}

		//TODO: loop through all connected clients with incoming data and handle their commands
		//  CHOICE: just store in masterFds (and remove on read()==0) unless we need to keep state
		//  if no printer object yet, or type config changed, create printer object
		//  dispatch request to printer object
	}

	return 0;
}

/*********************
 * PRIVATE FUNCTIONS *
 *********************/

bool Server::openSocket() {
	int rv;

	struct sockaddr_un addr;
	addr.sun_family = AF_UNIX;
	strcpy(addr.sun_path, socketPath_.c_str());

	socketFd_ = socket(AF_UNIX, SOCK_STREAM, 0);
	if (log_.checkError(socketFd_, "could not create domain socket")) return false;

	rv = unlink(addr.sun_path); //FIXME (corner case): this does look a bit dangerous in case of funky paths, check if it is a socket first?
	if (rv == -1 && errno != ENOENT && errno != ENOTDIR) /* ignore errors indicating the socket file did not exist */
		if (log_.checkError(rv, "could not unlink domain socket file")) return false;

	rv = bind(socketFd_, (struct sockaddr*)&addr, sizeof(sockaddr_un)); //what is up with the address_len parameter value? and SUN_LEN()?
	if (log_.checkError(rv, "could not bind domain socket")) return false;

	rv = listen(socketFd_, SOCKET_MAX_BACKLOG);
	if (log_.checkError(rv, "could not listen on domain socket")) return false;

	return true;
}

bool Server::closeSocket() {
	if (log_.checkError(close(socketFd_), "could not close domain socket")) return -1;
	socketFd_ = -1;

	return true;
}

//returns 0 to child, >0 to parent, -1 for error
int Server::forkProcess() {
	int rv;

	int child_pid = fork();
	switch(child_pid) {
	case -1:	//this is an error (no child created at all)
		log_.checkError(child_pid, "could not fork server");
		return -1;
		break;
	case 0:	//this is the child
		//TODO: setsid() should probably disabled if the server also spawns its own sub-servers
		rv = setsid();
		if(rv == -1) { //try to create a new session for the child so it's not a child anymore
			log_.checkError(rv, "could not create new session for forked process");
			return -1;
		}
		return 0;
		break;
	default:	//this is the parent with child_pid being the pid of the new child
		log_.log(Logger::INFO, "printserver forked to background. pid=%i\n", child_pid);
		return child_pid;
	}
}

int Server::openPort() {
	return serial_.open(serialPortName_.c_str());
}
