#include <errno.h>
#include <strings.h> /* for error generated by Eclipse on FD_ZERO()? */
#include <unistd.h>
#include <sys/select.h>
#include <sys/socket.h>
#include "Server.h"
#include "Client.h"
#include "../drivers/DriverFactory.h"

using std::string;

const bool Server::FORK_BY_DEFAULT = false;
const int Server::SOCKET_MAX_BACKLOG = 5; //private

Server::Server(const string& serialPortPath, const string& socketPath)
: socketPath_(socketPath),
  log_(Logger::getInstance()), socketFd_(-1),
  printerDriver_(DriverFactory::createDriver("ultimaker", serialPortPath))
{ /* empty */ }

Server::~Server() {
	closeSocket();
}

//returns -1 on error, >0 after fork or 0 after successful (not-fork) exit
int Server::start(bool fork) {
	if (socketFd_ >= 0) {
		log_.log(Logger::WARNING, "printserver already started");
		return 0; //TODO: do we need a better return value in this case?
	}

	log_.log(Logger::INFO, "starting printserver with socket path '%s'", socketPath_.c_str());
	if (!openSocket()) return false;

	//NOTE: ignore SIGPIPE, generated by send() when the other end closes the socket (see Beej's guide for details)
	//FIXME: replace this with sigaction()
	signal(SIGPIPE, SIG_IGN);

	if (fork) {
		//fork as late as possible (before any possibly lengthy operations like serial port things)
		int rv = forkProcess();
		if (rv < 0) {
			closeSocket();
		}

		if (rv != 0) return rv; //return rv unless we are a successfuly spawned child process
	}

	//HIER *** foutafhandeling niet vergeten
	//printer_.openConnection();

	fd_set masterFds;
	fd_set readFds;
	int maxFd = socketFd_;
	FD_ZERO(&masterFds);
	FD_SET(socketFd_, &masterFds);

	while (true) {
		//TODO: add timeout (or something more complex to accomodate periodic temperature readings etc)

		readFds = masterFds;
		log_.log(Logger::VERBOSE, "entering select(), maxfd=%i", maxFd);
		if (log_.checkError(
				::select(maxFd + 1, &readFds, NULL, NULL, NULL), /* use FD_SETSIZE instead of keeping maxfd? */
				"error in select()")) {
			//TODO: handle error (close down server <- needs function... and return with proper error value)
		}
		log_.log(Logger::VERBOSE, "returned from select()");

		if (FD_ISSET(socketFd_, &readFds)) {
			socklen_t len = sizeof(struct sockaddr_un);
			struct sockaddr_un peerAddr;
			int connFd = ::accept(socketFd_, (struct sockaddr*)&peerAddr, &len);
			maxFd = (connFd > maxFd ? connFd : maxFd);

			FD_SET(connFd, &masterFds);
			clients_.push_back(new Client(*this, connFd));
			log_.log(Logger::VERBOSE, "new client with fd %i", connFd);
		}

		for (vec_ClientP::iterator it = clients_.begin(); it != clients_.end(); /* increment inside loop */) {
			int rv = (*it)->readData();
			log_.checkError(rv, "cannot read from client");

			if (rv == 0) {
				log_.log(Logger::VERBOSE, "connection closed from client with fd %i", (*it)->getFileDescriptor());
				FD_CLR((*it)->getFileDescriptor(), &masterFds);
				delete(*it);
				it = clients_.erase(it);
			} else {
				log_.log(Logger::BULK, "read %i bytes from client with fd %i", rv, (*it)->getFileDescriptor());
				(*it)->runCommands();
				it++;
			}
		}
		log_.log(Logger::BULK, "looping");//TEMP
	}

	return 0;
}

AbstractDriver* Server::getDriver() {
	return printerDriver_;
}

const AbstractDriver* Server::getDriver() const {
	return printerDriver_;
}


/*********************
 * PRIVATE FUNCTIONS *
 *********************/

bool Server::openSocket() {
	int rv;

	struct sockaddr_un addr;
	addr.sun_family = AF_UNIX;
	strncpy(addr.sun_path, socketPath_.c_str(), sizeof(addr.sun_path));

	socketFd_ = socket(AF_UNIX, SOCK_STREAM, 0);
	if (log_.checkError(socketFd_, "could not create domain socket")) return false;

	rv = unlink(addr.sun_path); //FIXME (corner case): this does look a bit dangerous in case of funky paths, check if it is a socket first?
	if (rv == -1 && errno != ENOENT && errno != ENOTDIR) /* ignore errors indicating the socket file did not exist */
		if (log_.checkError(rv, "could not unlink domain socket file")) return false;

	rv = bind(socketFd_, (struct sockaddr*)&addr, sizeof(sockaddr_un)); //what is up with the address_len parameter value? and SUN_LEN()?
	if (log_.checkError(rv, "could not bind domain socket")) return false;

	rv = listen(socketFd_, SOCKET_MAX_BACKLOG);
	if (log_.checkError(rv, "could not listen on domain socket")) return false;

	return true;
}

bool Server::closeSocket() {
	if (log_.checkError(close(socketFd_), "could not close domain socket")) return -1;
	socketFd_ = -1;

	return true;
}

//returns 0 to child, >0 to parent, -1 for error
int Server::forkProcess() {
	int rv;

	int child_pid = fork();
	switch(child_pid) {
	case -1:	//this is an error (no child created at all)
		log_.checkError(child_pid, "could not fork server");
		return -1;
		break;
	case 0:	//this is the child
		//TODO: setsid() should probably disabled if the server also spawns its own sub-servers
		rv = setsid();
		if(rv == -1) { //try to create a new session for the child so it's not a child anymore
			log_.checkError(rv, "could not create new session for forked process");
			return -1;
		}
		return 0;
		break;
	default:	//this is the parent with child_pid being the pid of the new child
		log_.log(Logger::INFO, "printserver forked to background. pid=%i\n", child_pid);
		return child_pid;
	}
}
